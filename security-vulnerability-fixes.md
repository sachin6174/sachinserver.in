# Security Vulnerability Fixes Implementation Guide

This document provides concrete implementation steps to fix the critical security vulnerabilities identified in the sachinserver.in security audit.

## 1. XSS Prevention - HTML Sanitization

### Install DOMPurify
```bash
npm install dompurify
npm install @types/dompurify  # if using TypeScript
```

### Fix MarkdownRenderer Component

**File:** `/src/Tools/MarkdownRenderer/MarkdownRenderer.js`

```javascript
import DOMPurify from 'dompurify';

// Replace lines 480 and 531 with sanitized versions:

// Line 480 - Tutorial lesson preview
<div className="mini-preview" 
     dangerouslySetInnerHTML={{ 
         __html: DOMPurify.sanitize(marked(lesson.example), {
             ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'h1', 'h2', 'h3', 'ul', 'ol', 'li'],
             ALLOWED_ATTR: ['class']
         }) 
     }} />

// Line 531 - Live preview
<div className="markdown-preview split"
     dangerouslySetInnerHTML={{ 
         __html: DOMPurify.sanitize(renderedHtml, {
             ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'code', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'blockquote', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'a', 'img'],
             ALLOWED_ATTR: ['class', 'href', 'title', 'alt', 'src']
         }) 
     }} />

// Additionally, configure marked with safer options
useEffect(() => {
    const options = {
        breaks: true,
        gfm: true,
        tables: true,
        pedantic: false,
        sanitize: true,  // Enable built-in sanitization
        smartLists: true,
        smartypants: false
    };

    marked.setOptions({
        ...options,
        highlight: function (code, lang) {
            // Sanitize code before highlighting
            const sanitizedCode = DOMPurify.sanitize(code, {ALLOWED_TAGS: []});
            // ... rest of highlighting logic
            return sanitizedCode;
        }
    });
}, []);
```

### Fix LaTeX Renderer Component

**File:** `/src/Tools/LaTeXRenderer/LaTeXRenderer.js`

```javascript
import DOMPurify from 'dompurify';

// Replace dangerous HTML rendering with:
<div className="mini-preview" 
     dangerouslySetInnerHTML={{ 
         __html: DOMPurify.sanitize(renderLatexPreview(lesson.example), {
             ALLOWED_TAGS: ['span', 'div', 'sup', 'sub', 'br'],
             ALLOWED_ATTR: ['class', 'style']
         }) 
     }} />

<div className="latex-preview split"
     dangerouslySetInnerHTML={{ 
         __html: DOMPurify.sanitize(renderedHtml, {
             ALLOWED_TAGS: ['span', 'div', 'sup', 'sub', 'br', 'p', 'strong', 'em'],
             ALLOWED_ATTR: ['class', 'style']
         }) 
     }} />
```

## 2. Fix Cryptographic Implementation

### Install Proper Crypto Library
```bash
npm install crypto-js
```

### Fix CryptoTool Component

**File:** `/src/Tools/CryptoTool/CryptoTool.js`

```javascript
import React, { useState } from 'react';
import CryptoJS from 'crypto-js';
import './CryptoTool.css';

// Replace the weak EncryptionLog and DecryptionLog classes:
class EncryptionLog {
    static async finalEncryptionWithStringToEncrypt(stringToEncrypt, password) {
        if (!password) {
            throw new Error('Password is required for encryption');
        }
        
        try {
            const encrypted = CryptoJS.AES.encrypt(stringToEncrypt, password);
            return encrypted.toString();
        } catch (error) {
            throw new Error('Encryption failed: ' + error.message);
        }
    }
}

class DecryptionLog {
    static async finalDecryptionWithEncryptedString(encryptedString, password) {
        if (!password) {
            throw new Error('Password is required for decryption');
        }
        
        try {
            const decrypted = CryptoJS.AES.decrypt(encryptedString, password);
            const plaintext = decrypted.toString(CryptoJS.enc.Utf8);
            
            if (!plaintext) {
                throw new Error('Invalid password or corrupted data');
            }
            
            return plaintext;
        } catch (error) {
            throw new Error('Decryption failed: ' + error.message);
        }
    }
}

const CryptoTool = () => {
    const [textInput, setTextInput] = useState('');
    const [password, setPassword] = useState('');
    const [textOutput, setTextOutput] = useState('');
    const [file, setFile] = useState(null);
    const [fileOutput, setFileOutput] = useState(null);
    const [method, setMethod] = useState('encrypt');
    const [algorithm, setAlgorithm] = useState('AES');

    const handleTextProcess = async () => {
        try {
            if (!textInput.trim()) {
                throw new Error('Please enter text to process');
            }
            
            if (!password.trim()) {
                throw new Error('Password is required');
            }

            const result = method === 'encrypt' 
                ? await EncryptionLog.finalEncryptionWithStringToEncrypt(textInput, password)
                : await DecryptionLog.finalDecryptionWithEncryptedString(textInput, password);
            setTextOutput(result);
        } catch (err) {
            setTextOutput('Error: ' + err.message);
        }
    };

    return (
        <div className="crypto-tool">
            <div className="mode-selector">
                <button 
                    className={method === 'encrypt' ? 'active' : ''} 
                    onClick={() => setMethod('encrypt')}
                >
                    Encrypt
                </button>
                <button 
                    className={method === 'decrypt' ? 'active' : ''} 
                    onClick={() => setMethod('decrypt')}
                >
                    Decrypt
                </button>
            </div>

            <div className="algorithm-selector">
                <label>Algorithm:</label>
                <select value={algorithm} onChange={(e) => setAlgorithm(e.target.value)}>
                    <option value="AES">AES-256</option>
                </select>
            </div>

            <div className="sections-container">
                <section className="text-section">
                    <h3>Text {method === 'encrypt' ? 'Encryption' : 'Decryption'}</h3>
                    
                    <div className="password-section">
                        <label htmlFor="password">Password (required):</label>
                        <input
                            id="password"
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            placeholder="Enter encryption/decryption password"
                            required
                        />
                    </div>

                    <textarea
                        value={textInput}
                        onChange={(e) => setTextInput(e.target.value)}
                        placeholder={`Enter text to ${method}...`}
                        maxLength={10000}  // Add input length limit
                    />
                    
                    <button 
                        onClick={handleTextProcess}
                        disabled={!textInput.trim() || !password.trim()}
                    >
                        Process Text
                    </button>
                    
                    {textOutput && (
                        <div className="output-section">
                            <h4>Output</h4>
                            <pre>{textOutput}</pre>
                        </div>
                    )}
                </section>
            </div>
        </div>
    );
};

export default CryptoTool;
```

## 3. Content Security Policy Implementation

### Update index.html

**File:** `/public/index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="
      default-src 'self';
      script-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
      style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://fonts.gstatic.com;
      font-src 'self' https://fonts.gstatic.com;
      img-src 'self' data: https://via.placeholder.com;
      connect-src 'self';
      object-src 'none';
      base-uri 'self';
      form-action 'self';
      frame-ancestors 'none';
    ">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta http-equiv="Permissions-Policy" content="camera=(), microphone=(), geolocation=()">
    
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#6366f1" />
    <meta name="color-scheme" content="light dark" />
    
    <!-- Remove or add integrity checks to external scripts -->
    <title>Sachin Kumar - Mac/iOS Developer Portfolio</title>
    
    <!-- Load scripts with integrity checks -->
    <script src="./libs/crypto-js.min.js" 
            integrity="sha384-YOUR_CRYPTO_JS_HASH_HERE" 
            crossorigin="anonymous"></script>
    <script src="./libs/qrcode.min.js" 
            integrity="sha384-YOUR_QRCODE_HASH_HERE" 
            crossorigin="anonymous"></script>
    <script src="./libs/jsQR.js" 
            integrity="sha384-YOUR_JSQR_HASH_HERE" 
            crossorigin="anonymous"></script>
  </head>
  <body>
    <!-- Secure theme script -->
    <script>
      (function() {
        try {
          var stored = localStorage.getItem('isDarkMode');
          var isDark = stored !== null ? JSON.parse(stored) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches);
          var body = document.body;
          if (body) {
            var dark = 'dark-mode';
            var light = 'light-mode';
            body.classList.remove(isDark ? light : dark);
            body.classList.add(isDark ? dark : light);
          }
        } catch (e) {
          // Silently ignore errors
        }
      })();
    </script>
    
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>
```

## 4. Input Validation and Sanitization

### Create Input Validation Utility

**File:** `/src/utils/inputValidator.js`

```javascript
import DOMPurify from 'dompurify';

export class InputValidator {
    static sanitizeText(input, maxLength = 10000) {
        if (typeof input !== 'string') {
            throw new Error('Input must be a string');
        }
        
        if (input.length > maxLength) {
            throw new Error(`Input exceeds maximum length of ${maxLength} characters`);
        }
        
        return DOMPurify.sanitize(input, {ALLOWED_TAGS: []});
    }
    
    static validateJSON(jsonString) {
        try {
            const sanitized = this.sanitizeText(jsonString, 50000);
            return JSON.parse(sanitized);
        } catch (error) {
            throw new Error('Invalid JSON format');
        }
    }
    
    static validateXML(xmlString) {
        const sanitized = this.sanitizeText(xmlString, 50000);
        
        // Remove potentially dangerous XML entities
        const cleanXML = sanitized.replace(/<!ENTITY[^>]*>/gi, '');
        
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(cleanXML, "text/xml");
        
        if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
            throw new Error("Invalid XML format");
        }
        
        return cleanXML;
    }
    
    static validateFile(file, allowedTypes, maxSize = 5 * 1024 * 1024) {
        if (!file) {
            throw new Error('No file provided');
        }
        
        if (!allowedTypes.includes(file.type)) {
            throw new Error(`File type ${file.type} is not allowed`);
        }
        
        if (file.size > maxSize) {
            throw new Error(`File size exceeds ${maxSize / 1024 / 1024}MB limit`);
        }
        
        return true;
    }
    
    static sanitizeRegex(pattern) {
        // Prevent ReDoS attacks by limiting regex complexity
        const maxLength = 500;
        if (pattern.length > maxLength) {
            throw new Error('Regular expression too complex');
        }
        
        // Check for potentially dangerous patterns
        const dangerousPatterns = [
            /(.*\*.*){3,}/,  // Multiple nested quantifiers
            /(\(.*\)){10,}/, // Too many groups
            /(.{100,})/      // Very long literals
        ];
        
        for (const dangerous of dangerousPatterns) {
            if (dangerous.test(pattern)) {
                throw new Error('Regular expression pattern not allowed');
            }
        }
        
        return pattern;
    }
}
```

### Update JSONTool with Validation

**File:** `/src/Tools/JSONTool/JsonTool.js`

```javascript
import { InputValidator } from '../../utils/inputValidator';

const JsonTool = () => {
    const [input, setInput] = useState('');
    const [output, setOutput] = useState('');
    const [error, setError] = useState('');
    const [showTree, setShowTree] = useState(false);

    const formatJSON = () => {
        try {
            const parsed = InputValidator.validateJSON(input);
            setOutput(JSON.stringify(parsed, null, 2));
            setError('');
        } catch (err) {
            setError('Invalid JSON format');
            setOutput('');
        }
    };

    const handleInputChange = (e) => {
        const value = e.target.value;
        if (value.length > 50000) {
            setError('Input too large (max 50KB)');
            return;
        }
        setInput(value);
        setError('');
    };

    return (
        <div className="json-tool">
            <div className="tool-container">
                <div className="input-section">
                    <h3>Input JSON</h3>
                    <textarea
                        value={input}
                        onChange={handleInputChange}
                        placeholder="Paste your JSON here..."
                        className="full-width-input"
                        rows={12}
                        maxLength={50000}
                    />
                </div>
                {/* Rest of component */}
            </div>
        </div>
    );
};
```

## 5. Secure File Upload Implementation

### Update XMLTool with File Validation

**File:** `/src/Tools/XMLTool/XmlTool.js`

```javascript
import { InputValidator } from '../../utils/inputValidator';

const XmlTool = () => {
    // ... existing state

    const loadData = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        try {
            // Validate file before processing
            InputValidator.validateFile(file, [
                'text/xml',
                'application/xml',
                'text/plain'
            ], 5 * 1024 * 1024); // 5MB limit

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const content = InputValidator.validateXML(e.target.result);
                    setInput(content);
                    setError('');
                    setOutput('');
                } catch (error) {
                    setError('File validation failed: ' + error.message);
                }
            };
            
            reader.onerror = () => {
                setError('Error reading file');
            };
            
            reader.readAsText(file);
        } catch (error) {
            setError('File validation failed: ' + error.message);
        }
    };

    const formatXML = () => {
        try {
            const cleanXML = InputValidator.validateXML(input);
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(cleanXML, "text/xml");
            
            if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                throw new Error("Invalid XML");
            }

            // ... rest of formatting logic
        } catch (err) {
            setError('XML processing failed');
            setOutput('');
        }
    };

    // ... rest of component
};
```

## 6. Secure localStorage Implementation

### Update StorageService with Encryption

**File:** `/src/services/StorageService.js`

```javascript
import CryptoJS from 'crypto-js';
import eventBus, { Events } from './EventBus';

class LocalStorageStrategy extends StorageStrategy {
    constructor(encryptionKey = null) {
        super();
        this.storage = typeof window !== 'undefined' ? window.localStorage : null;
        this.encryptionKey = encryptionKey || this.generateKey();
    }

    generateKey() {
        // Generate a key from session data (not stored persistently)
        const sessionId = sessionStorage.getItem('sessionId') || Date.now().toString();
        return CryptoJS.SHA256(sessionId + 'security_salt').toString();
    }

    serialize(value, options = {}) {
        const data = {
            value,
            timestamp: Date.now(),
            version: '1.0'
        };

        if (options.ttl) {
            data.expires = Date.now() + options.ttl;
        }

        const jsonString = JSON.stringify(data);
        
        // Encrypt sensitive data
        if (options.encrypt || this.isSensitiveKey(options.key)) {
            return CryptoJS.AES.encrypt(jsonString, this.encryptionKey).toString();
        }

        return jsonString;
    }

    deserialize(serializedValue, options = {}) {
        try {
            let jsonString = serializedValue;
            
            // Decrypt if encrypted
            if (options.encrypt || this.isEncrypted(serializedValue)) {
                const decrypted = CryptoJS.AES.decrypt(serializedValue, this.encryptionKey);
                jsonString = decrypted.toString(CryptoJS.enc.Utf8);
                
                if (!jsonString) {
                    throw new Error('Decryption failed');
                }
            }
            
            const data = JSON.parse(jsonString);
            
            // Check if data has expired
            if (data.expires && Date.now() > data.expires) {
                return null;
            }

            return data.value;
        } catch {
            // Fallback for non-JSON values
            return null;
        }
    }

    isSensitiveKey(key) {
        const sensitivePatterns = [
            /password/i,
            /secret/i,
            /token/i,
            /key/i,
            /auth/i,
            /session/i,
            /api/i
        ];
        
        return key && sensitivePatterns.some(pattern => pattern.test(key));
    }

    isEncrypted(value) {
        // Simple heuristic to detect encrypted content
        return value && value.length > 50 && !value.includes('{') && !value.includes('[');
    }
}
```

## 7. API Security for APITool

### Update APITool with Security Controls

**File:** `/src/Tools/APITool/APITool.js`

```javascript
const APITool = () => {
    // ... existing state
    const [allowedDomains] = useState([
        'api.github.com',
        'jsonplaceholder.typicode.com',
        'httpbin.org',
        'reqres.in'
    ]);

    const validateUrl = (url) => {
        try {
            const urlObj = new URL(url);
            
            // Check protocol
            if (!['http:', 'https:'].includes(urlObj.protocol)) {
                throw new Error('Only HTTP and HTTPS protocols are allowed');
            }
            
            // Check for private IP ranges
            const hostname = urlObj.hostname;
            if (this.isPrivateIP(hostname)) {
                throw new Error('Requests to private IP addresses are not allowed');
            }
            
            // Check allowed domains (optional whitelist)
            // Uncomment to enforce domain whitelist:
            // if (!allowedDomains.some(domain => hostname.includes(domain))) {
            //     throw new Error('Domain not in allowed list');
            // }
            
            return true;
        } catch (error) {
            throw new Error('Invalid URL: ' + error.message);
        }
    };

    const isPrivateIP = (hostname) => {
        const privateRanges = [
            /^127\./,
            /^192\.168\./,
            /^10\./,
            /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
            /^localhost$/i,
            /^0\.0\.0\.0$/
        ];
        
        return privateRanges.some(range => range.test(hostname));
    };

    const sanitizeHeaders = (headers) => {
        const dangerousHeaders = [
            'authorization',
            'cookie',
            'x-forwarded-for',
            'x-real-ip'
        ];
        
        return headers.filter(header => 
            !dangerousHeaders.includes(header.key.toLowerCase())
        );
    };

    const sendRequest = async () => {
        setLoading(true);
        setError(null);
        
        try {
            // Validate URL
            validateUrl(url);
            
            // Sanitize headers
            const safeHeaders = sanitizeHeaders(headers);
            const headerObject = safeHeaders.reduce((acc, h) => {
                if (h.key && h.value) acc[h.key] = h.value;
                return acc;
            }, {});

            const requestOptions = {
                method,
                headers: headerObject,
                // Add request timeout
                signal: AbortSignal.timeout(30000) // 30 second timeout
            };

            if (['POST', 'PUT', 'PATCH'].includes(method) && body) {
                // Validate and limit body size
                if (body.length > 100000) { // 100KB limit
                    throw new Error('Request body too large');
                }
                requestOptions.body = body;
            }

            const response = await fetch(url, requestOptions);
            const responseText = await response.text();
            
            // Limit response size
            if (responseText.length > 500000) { // 500KB limit
                throw new Error('Response too large to display');
            }
            
            const responseData = {
                status: response.status,
                statusText: response.statusText,
                headers: Object.fromEntries(response.headers),
                body: responseText
            };

            setResponse(responseData);
            setHistory([{ method, url, response: responseData }, ...history.slice(0, 9)]);
        } catch (err) {
            if (err.name === 'AbortError') {
                setError('Request timed out');
            } else {
                setError(err.message);
            }
        } finally {
            setLoading(false);
        }
    };

    // ... rest of component
};
```

## 8. Update Package.json Security Scripts

### Add Security Testing Scripts

**File:** `/package.json`

```json
{
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    
    "security:audit": "npm audit",
    "security:fix": "npm audit fix",
    "security:check": "npm audit --audit-level moderate",
    "security:test": "npm run security:audit && npm run lint:security",
    
    "lint:security": "eslint --ext .js,.jsx src/ --config .eslintrc.security.js",
    
    "build:secure": "npm run security:check && npm run build",
    "precommit": "npm run security:check"
  }
}
```

### Create Security ESLint Config

**File:** `/.eslintrc.security.js`

```javascript
module.exports = {
  "extends": ["plugin:security/recommended"],
  "plugins": ["security"],
  "rules": {
    "security/detect-object-injection": "error",
    "security/detect-non-literal-regexp": "error",
    "security/detect-unsafe-regex": "error",
    "security/detect-buffer-noassert": "error",
    "security/detect-child-process": "error",
    "security/detect-disable-mustache-escape": "error",
    "security/detect-eval-with-expression": "error",
    "security/detect-no-csrf-before-method-override": "error",
    "security/detect-non-literal-fs-filename": "error",
    "security/detect-pseudoRandomBytes": "error",
    "security/detect-possible-timing-attacks": "error"
  }
};
```

## Implementation Priority

1. **Immediate (Day 1):**
   - Install DOMPurify and fix XSS vulnerabilities
   - Add Content Security Policy to index.html
   - Fix crypto tool implementation

2. **Week 1:**
   - Implement input validation utility
   - Add file upload security
   - Run `npm audit fix`

3. **Week 2:**
   - Implement secure localStorage
   - Add API security controls
   - Set up security testing scripts

4. **Ongoing:**
   - Regular dependency updates
   - Security monitoring
   - Code review with security focus

Run `npm install dompurify crypto-js` to get started with the critical fixes.