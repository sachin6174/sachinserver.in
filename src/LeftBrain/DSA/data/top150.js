export const top150Data = {
    title: 'Top 150 Interview Questions',
    description: 'LeetCode\'s curated list of the most frequently asked coding interview questions at top tech companies',
    questions: [
        // Array / String
        '--- Array / String ---',
        'Merge Sorted Array - https://leetcode.com/problems/merge-sorted-array/',
        'Remove Element - https://leetcode.com/problems/remove-element/',
        'Remove Duplicates from Sorted Array - https://leetcode.com/problems/remove-duplicates-from-sorted-array/',
        'Remove Duplicates from Sorted Array II - https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/',
        'Majority Element - https://leetcode.com/problems/majority-element/',
        'Rotate Array - https://leetcode.com/problems/rotate-array/',
        'Best Time to Buy and Sell Stock - https://leetcode.com/problems/best-time-to-buy-and-sell-stock/',
        'Best Time to Buy and Sell Stock II - https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/',
        'Jump Game - https://leetcode.com/problems/jump-game/',
        'Jump Game II - https://leetcode.com/problems/jump-game-ii/',
        'H-Index - https://leetcode.com/problems/h-index/',
        'Insert Delete GetRandom O(1) - https://leetcode.com/problems/insert-delete-getrandom-o1/',
        'Product of Array Except Self - https://leetcode.com/problems/product-of-array-except-self/',
        'Gas Station - https://leetcode.com/problems/gas-station/',
        'Candy - https://leetcode.com/problems/candy/',
        'Trapping Rain Water - https://leetcode.com/problems/trapping-rain-water/',
        'Roman to Integer - https://leetcode.com/problems/roman-to-integer/',
        'Integer to Roman - https://leetcode.com/problems/integer-to-roman/',
        'Length of Last Word - https://leetcode.com/problems/length-of-last-word/',
        'Longest Common Prefix - https://leetcode.com/problems/longest-common-prefix/',
        'Reverse Words in a String - https://leetcode.com/problems/reverse-words-in-a-string/',
        'Zigzag Conversion - https://leetcode.com/problems/zigzag-conversion/',
        'Find the Index of the First Occurrence in a String - https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/',
        'Text Justification - https://leetcode.com/problems/text-justification/',

        // Two Pointers
        '--- Two Pointers ---',
        'Valid Palindrome - https://leetcode.com/problems/valid-palindrome/',
        'Is Subsequence - https://leetcode.com/problems/is-subsequence/',
        'Two Sum II - Input Array Is Sorted - https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/',
        'Container With Most Water - https://leetcode.com/problems/container-with-most-water/',
        '3Sum - https://leetcode.com/problems/3sum/',

        // Sliding Window
        '--- Sliding Window ---',
        'Minimum Size Subarray Sum - https://leetcode.com/problems/minimum-size-subarray-sum/',
        'Longest Substring Without Repeating Characters - https://leetcode.com/problems/longest-substring-without-repeating-characters/',
        'Substring with Concatenation of All Words - https://leetcode.com/problems/substring-with-concatenation-of-all-words/',
        'Minimum Window Substring - https://leetcode.com/problems/minimum-window-substring/',

        // Matrix
        '--- Matrix ---',
        'Valid Sudoku - https://leetcode.com/problems/valid-sudoku/',
        'Spiral Matrix - https://leetcode.com/problems/spiral-matrix/',
        'Rotate Image - https://leetcode.com/problems/rotate-image/',
        'Set Matrix Zeroes - https://leetcode.com/problems/set-matrix-zeroes/',
        'Game of Life - https://leetcode.com/problems/game-of-life/',

        // Hashmap
        '--- Hashmap ---',
        'Ransom Note - https://leetcode.com/problems/ransom-note/',
        'Isomorphic Strings - https://leetcode.com/problems/isomorphic-strings/',
        'Word Pattern - https://leetcode.com/problems/word-pattern/',
        'Valid Anagram - https://leetcode.com/problems/valid-anagram/',
        'Group Anagrams - https://leetcode.com/problems/group-anagrams/',
        'Two Sum - https://leetcode.com/problems/two-sum/',
        'Happy Number - https://leetcode.com/problems/happy-number/',
        'Contains Duplicate II - https://leetcode.com/problems/contains-duplicate-ii/',
        'Longest Consecutive Sequence - https://leetcode.com/problems/longest-consecutive-sequence/',

        // Intervals
        '--- Intervals ---',
        'Summary Ranges - https://leetcode.com/problems/summary-ranges/',
        'Merge Intervals - https://leetcode.com/problems/merge-intervals/',
        'Insert Interval - https://leetcode.com/problems/insert-interval/',
        'Minimum Number of Arrows to Burst Balloons - https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/',

        // Stack
        '--- Stack ---',
        'Valid Parentheses - https://leetcode.com/problems/valid-parentheses/',
        'Simplify Path - https://leetcode.com/problems/simplify-path/',
        'Min Stack - https://leetcode.com/problems/min-stack/',
        'Evaluate Reverse Polish Notation - https://leetcode.com/problems/evaluate-reverse-polish-notation/',
        'Basic Calculator - https://leetcode.com/problems/basic-calculator/',

        // Linked List
        '--- Linked List ---',
        'Linked List Cycle - https://leetcode.com/problems/linked-list-cycle/',
        'Add Two Numbers - https://leetcode.com/problems/add-two-numbers/',
        'Merge Two Sorted Lists - https://leetcode.com/problems/merge-two-sorted-lists/',
        'Copy List with Random Pointer - https://leetcode.com/problems/copy-list-with-random-pointer/',
        'Reverse Linked List II - https://leetcode.com/problems/reverse-linked-list-ii/',
        'Reverse Nodes in k-Group - https://leetcode.com/problems/reverse-nodes-in-k-group/',
        'Remove Nth Node From End of List - https://leetcode.com/problems/remove-nth-node-from-end-of-list/',
        'Remove Duplicates from Sorted List II - https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/',
        'Rotate List - https://leetcode.com/problems/rotate-list/',
        'Partition List - https://leetcode.com/problems/partition-list/',
        'LRU Cache - https://leetcode.com/problems/lru-cache/',

        // Binary Tree General
        '--- Binary Tree General ---',
        'Maximum Depth of Binary Tree - https://leetcode.com/problems/maximum-depth-of-binary-tree/',
        'Same Tree - https://leetcode.com/problems/same-tree/',
        'Invert Binary Tree - https://leetcode.com/problems/invert-binary-tree/',
        'Symmetric Tree - https://leetcode.com/problems/symmetric-tree/',
        'Construct Binary Tree from Preorder and Inorder Traversal - https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/',
        'Construct Binary Tree from Inorder and Postorder Traversal - https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/',
        'Populating Next Right Pointers in Each Node II - https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/',
        'Flatten Binary Tree to Linked List - https://leetcode.com/problems/flatten-binary-tree-to-linked-list/',
        'Path Sum - https://leetcode.com/problems/path-sum/',
        'Sum Root to Leaf Numbers - https://leetcode.com/problems/sum-root-to-leaf-numbers/',
        'Binary Tree Maximum Path Sum - https://leetcode.com/problems/binary-tree-maximum-path-sum/',
        'Binary Search Tree Iterator - https://leetcode.com/problems/binary-search-tree-iterator/',
        'Count Complete Tree Nodes - https://leetcode.com/problems/count-complete-tree-nodes/',
        'Lowest Common Ancestor of a Binary Tree - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/',

        // Binary Tree BFS
        '--- Binary Tree BFS ---',
        'Binary Tree Right Side View - https://leetcode.com/problems/binary-tree-right-side-view/',
        'Average of Levels in Binary Tree - https://leetcode.com/problems/average-of-levels-in-binary-tree/',
        'Binary Tree Level Order Traversal - https://leetcode.com/problems/binary-tree-level-order-traversal/',
        'Binary Tree Zigzag Level Order Traversal - https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/',

        // Binary Search Tree
        '--- Binary Search Tree ---',
        'Minimum Absolute Difference in BST - https://leetcode.com/problems/minimum-absolute-difference-in-bst/',
        'Kth Smallest Element in a BST - https://leetcode.com/problems/kth-smallest-element-in-a-bst/',
        'Validate Binary Search Tree - https://leetcode.com/problems/validate-binary-search-tree/',

        // Graph General
        '--- Graph General ---',
        'Number of Islands - https://leetcode.com/problems/number-of-islands/',
        'Surrounded Regions - https://leetcode.com/problems/surrounded-regions/',
        'Clone Graph - https://leetcode.com/problems/clone-graph/',
        'Evaluate Division - https://leetcode.com/problems/evaluate-division/',
        'Course Schedule - https://leetcode.com/problems/course-schedule/',
        'Course Schedule II - https://leetcode.com/problems/course-schedule-ii/',

        // Graph BFS
        '--- Graph BFS ---',
        'Snakes and Ladders - https://leetcode.com/problems/snakes-and-ladders/',
        'Minimum Genetic Mutation - https://leetcode.com/problems/minimum-genetic-mutation/',
        'Word Ladder - https://leetcode.com/problems/word-ladder/',

        // Trie
        '--- Trie ---',
        'Implement Trie (Prefix Tree) - https://leetcode.com/problems/implement-trie-prefix-tree/',
        'Design Add and Search Words Data Structure - https://leetcode.com/problems/design-add-and-search-words-data-structure/',
        'Word Search II - https://leetcode.com/problems/word-search-ii/',

        // Backtracking
        '--- Backtracking ---',
        'Letter Combinations of a Phone Number - https://leetcode.com/problems/letter-combinations-of-a-phone-number/',
        'Combinations - https://leetcode.com/problems/combinations/',
        'Permutations - https://leetcode.com/problems/permutations/',
        'Combination Sum - https://leetcode.com/problems/combination-sum/',
        'N-Queens II - https://leetcode.com/problems/n-queens-ii/',
        'Generate Parentheses - https://leetcode.com/problems/generate-parentheses/',
        'Word Search - https://leetcode.com/problems/word-search/',

        // Divide & Conquer
        '--- Divide & Conquer ---',
        'Convert Sorted Array to Binary Search Tree - https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/',
        'Sort List - https://leetcode.com/problems/sort-list/',
        'Construct Quad Tree - https://leetcode.com/problems/construct-quad-tree/',
        'Merge k Sorted Lists - https://leetcode.com/problems/merge-k-sorted-lists/',

        // Kadane's Algorithm
        '--- Kadane\'s Algorithm ---',
        'Maximum Subarray - https://leetcode.com/problems/maximum-subarray/',
        'Maximum Sum Circular Subarray - https://leetcode.com/problems/maximum-sum-circular-subarray/',

        // Binary Search
        '--- Binary Search ---',
        'Search Insert Position - https://leetcode.com/problems/search-insert-position/',
        'Search a 2D Matrix - https://leetcode.com/problems/search-a-2d-matrix/',
        'Find Peak Element - https://leetcode.com/problems/find-peak-element/',
        'Search in Rotated Sorted Array - https://leetcode.com/problems/search-in-rotated-sorted-array/',
        'Find First and Last Position of Element in Sorted Array - https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/',
        'Find Minimum in Rotated Sorted Array - https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/',
        'Median of Two Sorted Arrays - https://leetcode.com/problems/median-of-two-sorted-arrays/',

        // Heap
        '--- Heap ---',
        'Kth Largest Element in an Array - https://leetcode.com/problems/kth-largest-element-in-an-array/',
        'IPO - https://leetcode.com/problems/ipo/',
        'Find K Pairs with Smallest Sums - https://leetcode.com/problems/find-k-pairs-with-smallest-sums/',
        'Find Median from Data Stream - https://leetcode.com/problems/find-median-from-data-stream/',

        // Bit Manipulation
        '--- Bit Manipulation ---',
        'Add Binary - https://leetcode.com/problems/add-binary/',
        'Reverse Bits - https://leetcode.com/problems/reverse-bits/',
        'Number of 1 Bits - https://leetcode.com/problems/number-of-1-bits/',
        'Single Number - https://leetcode.com/problems/single-number/',
        'Single Number II - https://leetcode.com/problems/single-number-ii/',
        'Bitwise AND of Numbers Range - https://leetcode.com/problems/bitwise-and-of-numbers-range/',

        // Math
        '--- Math ---',
        'Palindrome Number - https://leetcode.com/problems/palindrome-number/',
        'Plus One - https://leetcode.com/problems/plus-one/',
        'Factorial Trailing Zeroes - https://leetcode.com/problems/factorial-trailing-zeroes/',
        'Sqrt(x) - https://leetcode.com/problems/sqrtx/',
        'Pow(x, n) - https://leetcode.com/problems/powx-n/',
        'Max Points on a Line - https://leetcode.com/problems/max-points-on-a-line/',

        // 1D DP
        '--- 1D DP ---',
        'Climbing Stairs - https://leetcode.com/problems/climbing-stairs/',
        'House Robber - https://leetcode.com/problems/house-robber/',
        'Word Break - https://leetcode.com/problems/word-break/',
        'Coin Change - https://leetcode.com/problems/coin-change/',
        'Longest Increasing Subsequence - https://leetcode.com/problems/longest-increasing-subsequence/',

        // Multidimensional DP
        '--- Multidimensional DP ---',
        'Triangle - https://leetcode.com/problems/triangle/',
        'Minimum Path Sum - https://leetcode.com/problems/minimum-path-sum/',
        'Unique Paths II - https://leetcode.com/problems/unique-paths-ii/',
        'Longest Palindromic Substring - https://leetcode.com/problems/longest-palindromic-substring/',
        'Interleaving String - https://leetcode.com/problems/interleaving-string/',
        'Edit Distance - https://leetcode.com/problems/edit-distance/',
        'Best Time to Buy and Sell Stock III - https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/',
        'Best Time to Buy and Sell Stock IV - https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/',
        'Maximal Square - https://leetcode.com/problems/maximal-square/'
    ],
    explanation: `## LeetCode Top 150 Interview Questions

### What is this Study Plan?
The **Top 150 Interview Questions** is LeetCode's curated collection of the most **frequently asked coding interview questions** at top-tier tech companies like Google, Amazon, Microsoft, Meta, Apple, and Netflix.

### Why These 150 Problems?
‚úÖ **Industry Validated**: Questions directly from real interviews  
‚úÖ **Comprehensive Coverage**: All major data structures and algorithms  
‚úÖ **Difficulty Progression**: Easy ‚Üí Medium ‚Üí Hard for structured learning  
‚úÖ **Pattern Recognition**: Learn common problem-solving techniques  
‚úÖ **High Success Rate**: Mastering these significantly improves interview performance

### Study Plan Structure

**üìä Problem Distribution by Category:**
- **Array/String**: 24 problems (Foundation)
- **Dynamic Programming**: 24 problems (1D + 2D)
- **Binary Tree**: 20 problems (General + BFS + BST)
- **Linked List**: 13 problems
- **Hashmap**: 13 problems
- **Backtracking**: 11 problems
- **Graph**: 8 problems (General + BFS)
- **Binary Search**: 7 problems
- **Math**: 7 problems
- **Matrix**: 6 problems
- **Stack**: 5 problems
- **Bit Manipulation**: 5 problems
- **Two Pointers**: 5 problems
- **Sliding Window**: 4 problems
- **Heap**: 3 problems
- **Trie**: 3 problems
- **Others**: 6 problems

### üéØ Recommended Study Strategy

**Phase 1 (Weeks 1-2): Foundations**
1. Array/String ‚Üí Two Pointers ‚Üí Sliding Window
2. Stack ‚Üí Hashmap
3. Focus on: Basic operations and pattern recognition

**Phase 2 (Weeks 3-4): Data Structures**
1. Linked List ‚Üí Binary Tree General
2. Binary Search Tree ‚Üí Matrix
3. Focus on: Traversal patterns and manipulation

**Phase 3 (Weeks 5-6): Algorithms**
1. Binary Search ‚Üí Graph General
2. Backtracking ‚Üí Divide & Conquer
3. Focus on: Search algorithms and recursion

**Phase 4 (Weeks 7-8): Advanced**
1. Dynamic Programming (1D ‚Üí 2D)
2. Advanced topics: Trie, Heap, Bit Manipulation
3. Focus on: Optimization and complex patterns

### üí° Pro Tips for Success

**Daily Practice:**
- Solve 2-3 problems per day consistently
- Review and understand multiple solutions
- Practice writing clean, bug-free code

**Pattern Recognition:**
- Group similar problems together
- Learn templates for common patterns
- Practice variations of the same concept

**Time Management:**
- Easy: 15-20 minutes max
- Medium: 30-45 minutes max  
- Hard: 45-60 minutes max

**Interview Preparation:**
- Practice explaining your approach out loud
- Write code on whiteboard/paper first
- Consider edge cases and optimize solutions

### üèÜ Success Metrics
- **Completion Rate**: Aim for 100% of problems solved
- **Understanding**: Can explain solution without hints
- **Speed**: Solve within time limits consistently
- **Optimization**: Know multiple approaches per problem

This study plan has helped **thousands of engineers** land jobs at FAANG+ companies. The key is consistent practice and deep understanding rather than just memorizing solutions.`,
    javascript: {
        title: 'Top 150 Study Guide - JavaScript',
        code: `// Essential JavaScript Patterns for Top 150 Problems

// 1. Array Manipulation Patterns
// Remove duplicates from sorted array
function removeDuplicates(nums) {
    if (nums.length <= 1) return nums.length;
    
    let j = 1;
    for (let i = 1; i < nums.length; i++) {
        if (nums[i] !== nums[i - 1]) {
            nums[j] = nums[i];
            j++;
        }
    }
    return j;
}

// 2. Two Pointers Pattern
// Valid palindrome
function isPalindrome(s) {
    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');
    let left = 0, right = cleaned.length - 1;
    
    while (left < right) {
        if (cleaned[left] !== cleaned[right]) return false;
        left++;
        right--;
    }
    return true;
}

// 3. Sliding Window Pattern
// Longest substring without repeating characters
function lengthOfLongestSubstring(s) {
    const seen = new Set();
    let left = 0, maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        while (seen.has(s[right])) {
            seen.delete(s[left]);
            left++;
        }
        seen.add(s[right]);
        maxLength = Math.max(maxLength, right - left + 1);
    }
    return maxLength;
}

// 4. HashMap Pattern
// Two Sum
function twoSum(nums, target) {
    const map = new Map();
    
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (map.has(complement)) {
            return [map.get(complement), i];
        }
        map.set(nums[i], i);
    }
    return [];
}

// 5. Stack Pattern
// Valid parentheses
function isValid(s) {
    const stack = [];
    const pairs = { ')': '(', '}': '{', ']': '[' };
    
    for (const char of s) {
        if (char in pairs) {
            if (stack.pop() !== pairs[char]) return false;
        } else {
            stack.push(char);
        }
    }
    return stack.length === 0;
}

// 6. Linked List Pattern
// Reverse linked list
function reverseList(head) {
    let prev = null, current = head;
    
    while (current) {
        const next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    return prev;
}

// 7. Binary Tree DFS Pattern
// Maximum depth of binary tree
function maxDepth(root) {
    if (!root) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}

// 8. Binary Tree BFS Pattern
// Level order traversal
function levelOrder(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length) {
        const levelSize = queue.length;
        const level = [];
        
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            level.push(node.val);
            
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        result.push(level);
    }
    return result;
}

// 9. Backtracking Pattern
// Generate parentheses
function generateParenthesis(n) {
    const result = [];
    
    function backtrack(current, open, close) {
        if (current.length === 2 * n) {
            result.push(current);
            return;
        }
        
        if (open < n) {
            backtrack(current + '(', open + 1, close);
        }
        if (close < open) {
            backtrack(current + ')', open, close + 1);
        }
    }
    
    backtrack('', 0, 0);
    return result;
}

// 10. Dynamic Programming Pattern
// Climbing stairs
function climbStairs(n) {
    if (n <= 2) return n;
    
    let prev2 = 1, prev1 = 2;
    
    for (let i = 3; i <= n; i++) {
        const current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    return prev1;
}

// 11. Binary Search Pattern
// Search insert position
function searchInsert(nums, target) {
    let left = 0, right = nums.length - 1;
    
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        
        if (nums[mid] === target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}

// Usage Examples and Test Cases
console.log("Testing Top 150 Patterns:");

// Array manipulation
console.log(removeDuplicates([1,1,2,2,3])); // Should modify array and return 3

// Two pointers
console.log(isPalindrome("A man, a plan, a canal: Panama")); // true

// Sliding window
console.log(lengthOfLongestSubstring("abcabcbb")); // 3

// HashMap
console.log(twoSum([2,7,11,15], 9)); // [0,1]

// Stack
console.log(isValid("()[]{}")); // true

// DP
console.log(climbStairs(5)); // 8

// Binary search
console.log(searchInsert([1,3,5,6], 5)); // 2`
    },
    swift: {
        title: 'Top 150 Study Guide - Swift',
        code: `// Essential Swift Patterns for Top 150 Problems

// 1. Array Manipulation Patterns
// Remove duplicates from sorted array
func removeDuplicates(_ nums: inout [Int]) -> Int {
    guard nums.count > 1 else { return nums.count }
    
    var j = 1
    for i in 1..<nums.count {
        if nums[i] != nums[i - 1] {
            nums[j] = nums[i]
            j += 1
        }
    }
    return j
}

// 2. Two Pointers Pattern
// Valid palindrome
func isPalindrome(_ s: String) -> Bool {
    let cleaned = s.lowercased().filter { $0.isLetter || $0.isNumber }
    let chars = Array(cleaned)
    var left = 0, right = chars.count - 1
    
    while left < right {
        if chars[left] != chars[right] { return false }
        left += 1
        right -= 1
    }
    return true
}

// 3. Sliding Window Pattern
// Longest substring without repeating characters
func lengthOfLongestSubstring(_ s: String) -> Int {
    let chars = Array(s)
    var seen = Set<Character>()
    var left = 0, maxLength = 0
    
    for right in 0..<chars.count {
        while seen.contains(chars[right]) {
            seen.remove(chars[left])
            left += 1
        }
        seen.insert(chars[right])
        maxLength = max(maxLength, right - left + 1)
    }
    return maxLength
}

// 4. HashMap Pattern
// Two Sum
func twoSum(_ nums: [Int], _ target: Int) -> [Int] {
    var map = [Int: Int]()
    
    for (i, num) in nums.enumerated() {
        let complement = target - num
        if let complementIndex = map[complement] {
            return [complementIndex, i]
        }
        map[num] = i
    }
    return []
}

// 5. Stack Pattern
// Valid parentheses
func isValid(_ s: String) -> Bool {
    var stack = [Character]()
    let pairs: [Character: Character] = [")": "(", "}": "{", "]": "["]
    
    for char in s {
        if let opening = pairs[char] {
            if stack.popLast() != opening { return false }
        } else {
            stack.append(char)
        }
    }
    return stack.isEmpty
}

// 6. Linked List Pattern
// Definition for singly-linked list
class ListNode {
    var val: Int
    var next: ListNode?
    init() { self.val = 0; self.next = nil }
    init(_ val: Int) { self.val = val; self.next = nil }
    init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next }
}

// Reverse linked list
func reverseList(_ head: ListNode?) -> ListNode? {
    var prev: ListNode? = nil
    var current = head
    
    while let curr = current {
        let next = curr.next
        curr.next = prev
        prev = curr
        current = next
    }
    return prev
}

// 7. Binary Tree DFS Pattern
// Definition for a binary tree node
class TreeNode {
    var val: Int
    var left: TreeNode?
    var right: TreeNode?
    init() { self.val = 0; self.left = nil; self.right = nil }
    init(_ val: Int) { self.val = val; self.left = nil; self.right = nil }
    init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {
        self.val = val
        self.left = left
        self.right = right
    }
}

// Maximum depth of binary tree
func maxDepth(_ root: TreeNode?) -> Int {
    guard let root = root else { return 0 }
    return 1 + max(maxDepth(root.left), maxDepth(root.right))
}

// 8. Binary Tree BFS Pattern
// Level order traversal
func levelOrder(_ root: TreeNode?) -> [[Int]] {
    guard let root = root else { return [] }
    
    var result = [[Int]]()
    var queue = [root]
    
    while !queue.isEmpty {
        let levelSize = queue.count
        var level = [Int]()
        
        for _ in 0..<levelSize {
            let node = queue.removeFirst()
            level.append(node.val)
            
            if let left = node.left { queue.append(left) }
            if let right = node.right { queue.append(right) }
        }
        result.append(level)
    }
    return result
}

// 9. Backtracking Pattern
// Generate parentheses
func generateParenthesis(_ n: Int) -> [String] {
    var result = [String]()
    
    func backtrack(_ current: String, _ open: Int, _ close: Int) {
        if current.count == 2 * n {
            result.append(current)
            return
        }
        
        if open < n {
            backtrack(current + "(", open + 1, close)
        }
        if close < open {
            backtrack(current + ")", open, close + 1)
        }
    }
    
    backtrack("", 0, 0)
    return result
}

// 10. Dynamic Programming Pattern
// Climbing stairs
func climbStairs(_ n: Int) -> Int {
    if n <= 2 { return n }
    
    var prev2 = 1, prev1 = 2
    
    for _ in 3...n {
        let current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    }
    return prev1
}

// 11. Binary Search Pattern
// Search insert position
func searchInsert(_ nums: [Int], _ target: Int) -> Int {
    var left = 0, right = nums.count - 1
    
    while left <= right {
        let mid = left + (right - left) / 2
        
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return left
}

// 12. Matrix Pattern
// Set matrix zeroes
func setZeroes(_ matrix: inout [[Int]]) {
    let m = matrix.count, n = matrix[0].count
    var firstRowZero = false, firstColZero = false
    
    // Check first row and column
    for j in 0..<n {
        if matrix[0][j] == 0 { firstRowZero = true; break }
    }
    for i in 0..<m {
        if matrix[i][0] == 0 { firstColZero = true; break }
    }
    
    // Use first row and column as markers
    for i in 1..<m {
        for j in 1..<n {
            if matrix[i][j] == 0 {
                matrix[i][0] = 0
                matrix[0][j] = 0
            }
        }
    }
    
    // Set zeroes
    for i in 1..<m {
        for j in 1..<n {
            if matrix[i][0] == 0 || matrix[0][j] == 0 {
                matrix[i][j] = 0
            }
        }
    }
    
    // Handle first row and column
    if firstRowZero {
        for j in 0..<n { matrix[0][j] = 0 }
    }
    if firstColZero {
        for i in 0..<m { matrix[i][0] = 0 }
    }
}

// Usage Examples and Test Cases
print("Testing Top 150 Patterns:")

// Array manipulation
var testArray = [1,1,2,2,3]
print(removeDuplicates(&testArray)) // Should modify array and return 3

// Two pointers
print(isPalindrome("A man, a plan, a canal: Panama")) // true

// Sliding window
print(lengthOfLongestSubstring("abcabcbb")) // 3

// HashMap
print(twoSum([2,7,11,15], 9)) // [0,1]

// Stack
print(isValid("()[]{}" )) // true

// DP
print(climbStairs(5)) // 8

// Binary search
print(searchInsert([1,3,5,6], 5)) // 2`
    },
    cpp: {
        title: 'Top 150 Study Guide - C++',
        code: `#include <vector>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <stack>
#include <queue>
#include <algorithm>
#include <iostream>

using namespace std;

// Essential C++ Patterns for Top 150 Problems

// 1. Array Manipulation Patterns
// Remove duplicates from sorted array
int removeDuplicates(vector<int>& nums) {
    if (nums.size() <= 1) return nums.size();
    
    int j = 1;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] != nums[i - 1]) {
            nums[j] = nums[i];
            j++;
        }
    }
    return j;
}

// 2. Two Pointers Pattern
// Valid palindrome
bool isPalindrome(string s) {
    int left = 0, right = s.length() - 1;
    
    while (left < right) {
        while (left < right && !isalnum(s[left])) left++;
        while (left < right && !isalnum(s[right])) right--;
        
        if (tolower(s[left]) != tolower(s[right])) return false;
        left++;
        right--;
    }
    return true;
}

// 3. Sliding Window Pattern
// Longest substring without repeating characters
int lengthOfLongestSubstring(string s) {
    unordered_set<char> seen;
    int left = 0, maxLength = 0;
    
    for (int right = 0; right < s.length(); right++) {
        while (seen.count(s[right])) {
            seen.erase(s[left]);
            left++;
        }
        seen.insert(s[right]);
        maxLength = max(maxLength, right - left + 1);
    }
    return maxLength;
}

// 4. HashMap Pattern
// Two Sum
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.count(complement)) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {};
}

// 5. Stack Pattern
// Valid parentheses
bool isValid(string s) {
    stack<char> stk;
    unordered_map<char, char> pairs = {{')', '('}, {'}', '{'}, {']', '['}};
    
    for (char c : s) {
        if (pairs.count(c)) {
            if (stk.empty() || stk.top() != pairs[c]) return false;
            stk.pop();
        } else {
            stk.push(c);
        }
    }
    return stk.empty();
}

// 6. Linked List Pattern
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

// Reverse linked list
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* current = head;
    
    while (current) {
        ListNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    return prev;
}

// 7. Binary Tree DFS Pattern
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

// Maximum depth of binary tree
int maxDepth(TreeNode* root) {
    if (!root) return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
}

// 8. Binary Tree BFS Pattern
// Level order traversal
vector<vector<int>> levelOrder(TreeNode* root) {
    if (!root) return {};
    
    vector<vector<int>> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> level;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        result.push_back(level);
    }
    return result;
}

// 9. Backtracking Pattern
// Generate parentheses
vector<string> generateParenthesis(int n) {
    vector<string> result;
    
    function<void(string, int, int)> backtrack = [&](string current, int open, int close) {
        if (current.length() == 2 * n) {
            result.push_back(current);
            return;
        }
        
        if (open < n) {
            backtrack(current + "(", open + 1, close);
        }
        if (close < open) {
            backtrack(current + ")", open, close + 1);
        }
    };
    
    backtrack("", 0, 0);
    return result;
}

// 10. Dynamic Programming Pattern
// Climbing stairs
int climbStairs(int n) {
    if (n <= 2) return n;
    
    int prev2 = 1, prev1 = 2;
    
    for (int i = 3; i <= n; i++) {
        int current = prev1 + prev2;
        prev2 = prev1;
        prev1 = current;
    }
    return prev1;
}

// 11. Binary Search Pattern
// Search insert position
int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}

// 12. Matrix Pattern
// Set matrix zeroes
void setZeroes(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    bool firstRowZero = false, firstColZero = false;
    
    // Check first row and column
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) { firstRowZero = true; break; }
    }
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) { firstColZero = true; break; }
    }
    
    // Use first row and column as markers
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    
    // Set zeroes
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }
    
    // Handle first row and column
    if (firstRowZero) {
        for (int j = 0; j < n; j++) matrix[0][j] = 0;
    }
    if (firstColZero) {
        for (int i = 0; i < m; i++) matrix[i][0] = 0;
    }
}

// Usage Examples and Test Cases
int main() {
    cout << "Testing Top 150 Patterns:" << endl;
    
    // Array manipulation
    vector<int> testArray = {1,1,2,2,3};
    cout << "Remove duplicates result: " << removeDuplicates(testArray) << endl;
    
    // Two pointers
    cout << "Is palindrome: " << isPalindrome("A man, a plan, a canal: Panama") << endl;
    
    // Sliding window
    cout << "Longest substring: " << lengthOfLongestSubstring("abcabcbb") << endl;
    
    // HashMap
    vector<int> nums = {2,7,11,15};
    vector<int> result = twoSum(nums, 9);
    cout << "Two sum result: [" << result[0] << "," << result[1] << "]" << endl;
    
    // Stack
    cout << "Valid parentheses: " << isValid("()[]{}" ) << endl;
    
    // DP
    cout << "Climb stairs: " << climbStairs(5) << endl;
    
    // Binary search
    vector<int> sortedNums = {1,3,5,6};
    cout << "Search insert: " << searchInsert(sortedNums, 5) << endl;
    
    return 0;
}`
    }
};